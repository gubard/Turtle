// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Sqlite.Storage.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Turtle.Contract.Models;

#pragma warning disable 219, 612, 618
#nullable disable

namespace Turtle.CompiledModels
{
    [EntityFrameworkInternal]
    public partial class CredentialEntityEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "Turtle.Contract.Models.CredentialEntity",
                typeof(CredentialEntity),
                baseEntityType,
                propertyCount: 14,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(Guid),
                propertyInfo: typeof(CredentialEntity).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: new Guid("00000000-0000-0000-0000-000000000000"));
            id.SetGetter(
                Guid (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Id(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Id(instance) == new Guid("00000000-0000-0000-0000-000000000000"));
            id.SetSetter(
                CredentialEntity (CredentialEntity instance, Guid value) =>
                {
                    CredentialEntityUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, Guid value) =>
                {
                    CredentialEntityUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetAccessors(
                Guid (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Id(((CredentialEntity)(entry.Entity))),
                Guid (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Id(((CredentialEntity)(entry.Entity))),
                Guid (IInternalEntry entry) => entry.ReadOriginalValue<Guid>(id, 0),
                Guid (IInternalEntry entry) => ((InternalEntityEntry)(entry)).ReadRelationshipSnapshotValue<Guid>(id, 0));
            id.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: -1,
                relationshipIndex: 0,
                storeGenerationIndex: -1);
            id.TypeMapping = SqliteGuidTypeMapping.Default;
            id.SetCurrentValueComparer(new EntryCurrentValueComparer<Guid>(id));
            id.SetComparer(new ValueComparer<Guid>(
                bool (Guid c1, Guid c2) => c1 == c2,
                int (Guid c) => ((object)c).GetHashCode(),
                Guid (Guid c) => c));

            var customAvailableCharacters = runtimeEntityType.AddProperty(
                "CustomAvailableCharacters",
                typeof(string),
                propertyInfo: typeof(CredentialEntity).GetProperty("CustomAvailableCharacters", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<CustomAvailableCharacters>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 1000);
            customAvailableCharacters.SetGetter(
                string (CredentialEntity instance) => CredentialEntityUnsafeAccessors.CustomAvailableCharacters(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.CustomAvailableCharacters(instance) == null);
            customAvailableCharacters.SetSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.CustomAvailableCharacters(instance) = value;
                    return instance;
                });
            customAvailableCharacters.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.CustomAvailableCharacters(instance) = value;
                    return instance;
                });
            customAvailableCharacters.SetAccessors(
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.CustomAvailableCharacters(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.CustomAvailableCharacters(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(customAvailableCharacters, 1),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(customAvailableCharacters));
            customAvailableCharacters.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            customAvailableCharacters.TypeMapping = SqliteStringTypeMapping.Default;

            var isAvailableLowerLatin = runtimeEntityType.AddProperty(
                "IsAvailableLowerLatin",
                typeof(bool),
                propertyInfo: typeof(CredentialEntity).GetProperty("IsAvailableLowerLatin", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<IsAvailableLowerLatin>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isAvailableLowerLatin.SetGetter(
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableLowerLatin(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableLowerLatin(instance) == false);
            isAvailableLowerLatin.SetSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableLowerLatin(instance) = value;
                    return instance;
                });
            isAvailableLowerLatin.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableLowerLatin(instance) = value;
                    return instance;
                });
            isAvailableLowerLatin.SetAccessors(
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableLowerLatin(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableLowerLatin(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isAvailableLowerLatin, 2),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isAvailableLowerLatin));
            isAvailableLowerLatin.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isAvailableLowerLatin.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var isAvailableNumber = runtimeEntityType.AddProperty(
                "IsAvailableNumber",
                typeof(bool),
                propertyInfo: typeof(CredentialEntity).GetProperty("IsAvailableNumber", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<IsAvailableNumber>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isAvailableNumber.SetGetter(
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableNumber(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableNumber(instance) == false);
            isAvailableNumber.SetSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableNumber(instance) = value;
                    return instance;
                });
            isAvailableNumber.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableNumber(instance) = value;
                    return instance;
                });
            isAvailableNumber.SetAccessors(
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableNumber(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableNumber(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isAvailableNumber, 3),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isAvailableNumber));
            isAvailableNumber.SetPropertyIndexes(
                index: 3,
                originalValueIndex: 3,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isAvailableNumber.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var isAvailableSpecialSymbols = runtimeEntityType.AddProperty(
                "IsAvailableSpecialSymbols",
                typeof(bool),
                propertyInfo: typeof(CredentialEntity).GetProperty("IsAvailableSpecialSymbols", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<IsAvailableSpecialSymbols>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isAvailableSpecialSymbols.SetGetter(
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableSpecialSymbols(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableSpecialSymbols(instance) == false);
            isAvailableSpecialSymbols.SetSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableSpecialSymbols(instance) = value;
                    return instance;
                });
            isAvailableSpecialSymbols.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableSpecialSymbols(instance) = value;
                    return instance;
                });
            isAvailableSpecialSymbols.SetAccessors(
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableSpecialSymbols(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableSpecialSymbols(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isAvailableSpecialSymbols, 4),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isAvailableSpecialSymbols));
            isAvailableSpecialSymbols.SetPropertyIndexes(
                index: 4,
                originalValueIndex: 4,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isAvailableSpecialSymbols.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var isAvailableUpperLatin = runtimeEntityType.AddProperty(
                "IsAvailableUpperLatin",
                typeof(bool),
                propertyInfo: typeof(CredentialEntity).GetProperty("IsAvailableUpperLatin", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<IsAvailableUpperLatin>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: false);
            isAvailableUpperLatin.SetGetter(
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableUpperLatin(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.IsAvailableUpperLatin(instance) == false);
            isAvailableUpperLatin.SetSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableUpperLatin(instance) = value;
                    return instance;
                });
            isAvailableUpperLatin.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, bool value) =>
                {
                    CredentialEntityUnsafeAccessors.IsAvailableUpperLatin(instance) = value;
                    return instance;
                });
            isAvailableUpperLatin.SetAccessors(
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableUpperLatin(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => CredentialEntityUnsafeAccessors.IsAvailableUpperLatin(((CredentialEntity)(entry.Entity))),
                bool (IInternalEntry entry) => entry.ReadOriginalValue<bool>(isAvailableUpperLatin, 5),
                bool (IInternalEntry entry) => entry.GetCurrentValue<bool>(isAvailableUpperLatin));
            isAvailableUpperLatin.SetPropertyIndexes(
                index: 5,
                originalValueIndex: 5,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            isAvailableUpperLatin.TypeMapping = BoolTypeMapping.Default.Clone(
                comparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                keyComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                providerValueComparer: new ValueComparer<bool>(
                    bool (bool v1, bool v2) => v1 == v2,
                    int (bool v) => ((object)v).GetHashCode(),
                    bool (bool v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var key = runtimeEntityType.AddProperty(
                "Key",
                typeof(string),
                propertyInfo: typeof(CredentialEntity).GetProperty("Key", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Key>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 255);
            key.SetGetter(
                string (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Key(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Key(instance) == null);
            key.SetSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Key(instance) = value;
                    return instance;
                });
            key.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Key(instance) = value;
                    return instance;
                });
            key.SetAccessors(
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Key(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Key(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(key, 6),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(key));
            key.SetPropertyIndexes(
                index: 6,
                originalValueIndex: 6,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            key.TypeMapping = SqliteStringTypeMapping.Default;

            var length = runtimeEntityType.AddProperty(
                "Length",
                typeof(ushort),
                propertyInfo: typeof(CredentialEntity).GetProperty("Length", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Length>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: (ushort)0);
            length.SetGetter(
                ushort (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Length(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Length(instance) == 0);
            length.SetSetter(
                CredentialEntity (CredentialEntity instance, ushort value) =>
                {
                    CredentialEntityUnsafeAccessors.Length(instance) = value;
                    return instance;
                });
            length.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, ushort value) =>
                {
                    CredentialEntityUnsafeAccessors.Length(instance) = value;
                    return instance;
                });
            length.SetAccessors(
                ushort (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Length(((CredentialEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Length(((CredentialEntity)(entry.Entity))),
                ushort (IInternalEntry entry) => entry.ReadOriginalValue<ushort>(length, 7),
                ushort (IInternalEntry entry) => entry.GetCurrentValue<ushort>(length));
            length.SetPropertyIndexes(
                index: 7,
                originalValueIndex: 7,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            length.TypeMapping = UShortTypeMapping.Default.Clone(
                comparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                keyComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                providerValueComparer: new ValueComparer<ushort>(
                    bool (ushort v1, ushort v2) => v1 == v2,
                    int (ushort v) => ((int)(v)),
                    ushort (ushort v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var login = runtimeEntityType.AddProperty(
                "Login",
                typeof(string),
                propertyInfo: typeof(CredentialEntity).GetProperty("Login", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Login>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 255);
            login.SetGetter(
                string (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Login(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Login(instance) == null);
            login.SetSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Login(instance) = value;
                    return instance;
                });
            login.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Login(instance) = value;
                    return instance;
                });
            login.SetAccessors(
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Login(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Login(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(login, 8),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(login));
            login.SetPropertyIndexes(
                index: 8,
                originalValueIndex: 8,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            login.TypeMapping = SqliteStringTypeMapping.Default;

            var name = runtimeEntityType.AddProperty(
                "Name",
                typeof(string),
                propertyInfo: typeof(CredentialEntity).GetProperty("Name", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Name>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 255);
            name.SetGetter(
                string (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Name(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Name(instance) == null);
            name.SetSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Name(instance) = value;
                    return instance;
                });
            name.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Name(instance) = value;
                    return instance;
                });
            name.SetAccessors(
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Name(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Name(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(name, 9),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(name));
            name.SetPropertyIndexes(
                index: 9,
                originalValueIndex: 9,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            name.TypeMapping = SqliteStringTypeMapping.Default;

            var orderIndex = runtimeEntityType.AddProperty(
                "OrderIndex",
                typeof(uint),
                propertyInfo: typeof(CredentialEntity).GetProperty("OrderIndex", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<OrderIndex>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                sentinel: 0u);
            orderIndex.SetGetter(
                uint (CredentialEntity instance) => CredentialEntityUnsafeAccessors.OrderIndex(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.OrderIndex(instance) == 0U);
            orderIndex.SetSetter(
                CredentialEntity (CredentialEntity instance, uint value) =>
                {
                    CredentialEntityUnsafeAccessors.OrderIndex(instance) = value;
                    return instance;
                });
            orderIndex.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, uint value) =>
                {
                    CredentialEntityUnsafeAccessors.OrderIndex(instance) = value;
                    return instance;
                });
            orderIndex.SetAccessors(
                uint (IInternalEntry entry) => CredentialEntityUnsafeAccessors.OrderIndex(((CredentialEntity)(entry.Entity))),
                uint (IInternalEntry entry) => CredentialEntityUnsafeAccessors.OrderIndex(((CredentialEntity)(entry.Entity))),
                uint (IInternalEntry entry) => entry.ReadOriginalValue<uint>(orderIndex, 10),
                uint (IInternalEntry entry) => entry.GetCurrentValue<uint>(orderIndex));
            orderIndex.SetPropertyIndexes(
                index: 10,
                originalValueIndex: 10,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            orderIndex.TypeMapping = UIntTypeMapping.Default.Clone(
                comparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                keyComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                providerValueComparer: new ValueComparer<uint>(
                    bool (uint v1, uint v2) => v1 == v2,
                    int (uint v) => ((int)(v)),
                    uint (uint v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"));

            var parentId = runtimeEntityType.AddProperty(
                "ParentId",
                typeof(Guid?),
                propertyInfo: typeof(CredentialEntity).GetProperty("ParentId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<ParentId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            parentId.SetGetter(
                Guid? (CredentialEntity instance) => CredentialEntityUnsafeAccessors.ParentId(instance),
                bool (CredentialEntity instance) => !(CredentialEntityUnsafeAccessors.ParentId(instance).HasValue));
            parentId.SetSetter(
                CredentialEntity (CredentialEntity instance, Guid? value) =>
                {
                    CredentialEntityUnsafeAccessors.ParentId(instance) = value;
                    return instance;
                });
            parentId.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, Guid? value) =>
                {
                    CredentialEntityUnsafeAccessors.ParentId(instance) = value;
                    return instance;
                });
            parentId.SetAccessors(
                Guid? (IInternalEntry entry) => CredentialEntityUnsafeAccessors.ParentId(((CredentialEntity)(entry.Entity))),
                Guid? (IInternalEntry entry) => CredentialEntityUnsafeAccessors.ParentId(((CredentialEntity)(entry.Entity))),
                Guid? (IInternalEntry entry) => entry.ReadOriginalValue<Guid?>(parentId, 11),
                Guid? (IInternalEntry entry) => entry.GetCurrentValue<Guid?>(parentId));
            parentId.SetPropertyIndexes(
                index: 11,
                originalValueIndex: 11,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            parentId.TypeMapping = SqliteGuidTypeMapping.Default;
            parentId.SetComparer(new ValueComparer<Guid?>(
                bool (Guid? c1, Guid? c2) => c1 == c2,
                int (Guid? c) => ((object)c).GetHashCode(),
                Guid? (Guid? c) => c));

            var regex = runtimeEntityType.AddProperty(
                "Regex",
                typeof(string),
                propertyInfo: typeof(CredentialEntity).GetProperty("Regex", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Regex>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 255);
            regex.SetGetter(
                string (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Regex(instance),
                bool (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Regex(instance) == null);
            regex.SetSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Regex(instance) = value;
                    return instance;
                });
            regex.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, string value) =>
                {
                    CredentialEntityUnsafeAccessors.Regex(instance) = value;
                    return instance;
                });
            regex.SetAccessors(
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Regex(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Regex(((CredentialEntity)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(regex, 12),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(regex));
            regex.SetPropertyIndexes(
                index: 12,
                originalValueIndex: 12,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            regex.TypeMapping = SqliteStringTypeMapping.Default;

            var type = runtimeEntityType.AddProperty(
                "Type",
                typeof(CredentialType),
                propertyInfo: typeof(CredentialEntity).GetProperty("Type", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(CredentialEntity).GetField("<Type>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
            type.SetGetter(
                CredentialType (CredentialEntity instance) => CredentialEntityUnsafeAccessors.Type(instance),
                bool (CredentialEntity instance) => object.Equals(((object)(CredentialEntityUnsafeAccessors.Type(instance))), ((object)(CredentialType.Value))));
            type.SetSetter(
                CredentialEntity (CredentialEntity instance, CredentialType value) =>
                {
                    CredentialEntityUnsafeAccessors.Type(instance) = value;
                    return instance;
                });
            type.SetMaterializationSetter(
                CredentialEntity (CredentialEntity instance, CredentialType value) =>
                {
                    CredentialEntityUnsafeAccessors.Type(instance) = value;
                    return instance;
                });
            type.SetAccessors(
                CredentialType (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Type(((CredentialEntity)(entry.Entity))),
                CredentialType (IInternalEntry entry) => CredentialEntityUnsafeAccessors.Type(((CredentialEntity)(entry.Entity))),
                CredentialType (IInternalEntry entry) => entry.ReadOriginalValue<CredentialType>(type, 13),
                CredentialType (IInternalEntry entry) => entry.GetCurrentValue<CredentialType>(type));
            type.SetPropertyIndexes(
                index: 13,
                originalValueIndex: 13,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            type.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<CredentialType>(
                    bool (CredentialType v1, CredentialType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CredentialType v) => ((object)v).GetHashCode(),
                    CredentialType (CredentialType v) => v),
                keyComparer: new ValueComparer<CredentialType>(
                    bool (CredentialType v1, CredentialType v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (CredentialType v) => ((object)v).GetHashCode(),
                    CredentialType (CredentialType v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "INTEGER"),
                converter: new ValueConverter<CredentialType, byte>(
                    byte (CredentialType value) => ((byte)(value)),
                    CredentialType (byte value) => ((CredentialType)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<CredentialType, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<CredentialType, byte>(
                        byte (CredentialType value) => ((byte)(value)),
                        CredentialType (byte value) => ((CredentialType)(value)))));
            type.SetSentinelFromProviderValue((byte)0);

            var key0 = runtimeEntityType.AddKey(
                new[] { id });
            runtimeEntityType.SetPrimaryKey(key0);

            return runtimeEntityType;
        }

        public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
        {
            var id = runtimeEntityType.FindProperty("Id");
            var customAvailableCharacters = runtimeEntityType.FindProperty("CustomAvailableCharacters");
            var isAvailableLowerLatin = runtimeEntityType.FindProperty("IsAvailableLowerLatin");
            var isAvailableNumber = runtimeEntityType.FindProperty("IsAvailableNumber");
            var isAvailableSpecialSymbols = runtimeEntityType.FindProperty("IsAvailableSpecialSymbols");
            var isAvailableUpperLatin = runtimeEntityType.FindProperty("IsAvailableUpperLatin");
            var key = runtimeEntityType.FindProperty("Key");
            var length = runtimeEntityType.FindProperty("Length");
            var login = runtimeEntityType.FindProperty("Login");
            var name = runtimeEntityType.FindProperty("Name");
            var orderIndex = runtimeEntityType.FindProperty("OrderIndex");
            var parentId = runtimeEntityType.FindProperty("ParentId");
            var regex = runtimeEntityType.FindProperty("Regex");
            var type = runtimeEntityType.FindProperty("Type");
            var key0 = runtimeEntityType.FindKey(new[] { id });
            key0.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<Guid>(key0));
            key0.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<Guid>(key0));
            runtimeEntityType.SetOriginalValuesFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((CredentialEntity)(source.Entity));
                    return ((ISnapshot)(new Snapshot<Guid, string, bool, bool, bool, bool, string, ushort, string, string, uint, Guid?, string, CredentialType>(((ValueComparer<Guid>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid>(id)), (source.GetCurrentValue<string>(customAvailableCharacters) == null ? null : ((ValueComparer<string>)(((IProperty)customAvailableCharacters).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(customAvailableCharacters))), ((ValueComparer<bool>)(((IProperty)isAvailableLowerLatin).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isAvailableLowerLatin)), ((ValueComparer<bool>)(((IProperty)isAvailableNumber).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isAvailableNumber)), ((ValueComparer<bool>)(((IProperty)isAvailableSpecialSymbols).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isAvailableSpecialSymbols)), ((ValueComparer<bool>)(((IProperty)isAvailableUpperLatin).GetValueComparer())).Snapshot(source.GetCurrentValue<bool>(isAvailableUpperLatin)), (source.GetCurrentValue<string>(key) == null ? null : ((ValueComparer<string>)(((IProperty)key).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(key))), ((ValueComparer<ushort>)(((IProperty)length).GetValueComparer())).Snapshot(source.GetCurrentValue<ushort>(length)), (source.GetCurrentValue<string>(login) == null ? null : ((ValueComparer<string>)(((IProperty)login).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(login))), (source.GetCurrentValue<string>(name) == null ? null : ((ValueComparer<string>)(((IProperty)name).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(name))), ((ValueComparer<uint>)(((IProperty)orderIndex).GetValueComparer())).Snapshot(source.GetCurrentValue<uint>(orderIndex)), (source.GetCurrentValue<Guid?>(parentId) == null ? null : ((ValueComparer<Guid?>)(((IProperty)parentId).GetValueComparer())).Snapshot(source.GetCurrentValue<Guid?>(parentId))), (source.GetCurrentValue<string>(regex) == null ? null : ((ValueComparer<string>)(((IProperty)regex).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(regex))), ((ValueComparer<CredentialType>)(((IProperty)type).GetValueComparer())).Snapshot(source.GetCurrentValue<CredentialType>(type)))));
                });
            runtimeEntityType.SetStoreGeneratedValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetTemporaryValuesFactory(
                ISnapshot (IInternalEntry source) => Snapshot.Empty);
            runtimeEntityType.SetShadowValuesFactory(
                ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
            runtimeEntityType.SetEmptyShadowValuesFactory(
                ISnapshot () => Snapshot.Empty);
            runtimeEntityType.SetRelationshipSnapshotFactory(
                ISnapshot (IInternalEntry source) =>
                {
                    var structuralType = ((CredentialEntity)(source.Entity));
                    return ((ISnapshot)(new Snapshot<Guid>(((ValueComparer<Guid>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<Guid>(id)))));
                });
            runtimeEntityType.SetCounts(new PropertyCounts(
                propertyCount: 14,
                navigationCount: 0,
                complexPropertyCount: 0,
                complexCollectionCount: 0,
                originalValueCount: 14,
                shadowCount: 0,
                relationshipCount: 1,
                storeGeneratedCount: 0));
            runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
            runtimeEntityType.AddAnnotation("Relational:Schema", null);
            runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
            runtimeEntityType.AddAnnotation("Relational:TableName", "Credentials");
            runtimeEntityType.AddAnnotation("Relational:ViewName", null);
            runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

            Customize(runtimeEntityType);
        }

        static partial void Customize(RuntimeEntityType runtimeEntityType);
    }
}
